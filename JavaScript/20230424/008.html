<!DOCTYPE html>
<html lang="ko">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <p>hello lions!!</p>
  <button type="button">통신버튼</button>



  <script>
    const btn = document.querySelector('button');
    // btn.addEventListener('click', xhrRequest);
    // 사용자가 button 클릭하는 것을 btn으로 가져오고
    let result;

    function xhrRequest() {
      const xhr = new XMLHttpRequest(); //XMLHttpRequest 생성해서 xhr에 저장
      xhr.open('GET', 'message.txt');// 요청을 초기화합니다. 통신방법과 요청을 발신할 대상의 주소를 전달합니다.

      xhr.onreadystatechange = () => { //xhr의 상태값이 변경될때마다 호출되는 콜백함수 등록, 호출결과 받아볼 수 있음 // readystate 가 변화하면 실행되는 이벤트리스너 입니다.

        // readystate : 요청을 보내는 클라이언트의 상태를 의미합니다.
        // readystate의 종류
        // 0 (UNSENT) - XHR 객체가 생성되었지만 아직 초기화되지 않았습니다.
        // 1 (OPENED) - open()함수가 호출되어 요청이 초기화되었습니다.
        // 2 (HEADERS_RECEIVED) - send()함수가 호출되었습니다.
        // 3 (LOADING) - 데이터를 다운받는 중 입니다.
        // 4 (DONE) - 통신이 완료되었습니다.

        if (xhr.readyState === 4 && xhr.status === 200) {//서버와의 통신상태를 나타낸다면, status는 서버의 응답상태를 나타냅니다.200은 요청한 내용이 성공적으로 완료되었음을 의미합니다.

          //개발자들은 종종 readyState와 status를 혼동합니다. 간단한 비유로 설명해보겠습니다.
          //배가 너무 고파서 1시간 후에 집에서 저녁을 먹기 위해 피자를 주문해야 합니다.그래서 배달앱을 꺼내 피자를 한판 주문합니다.
          //이때 배달하는 사람이 피자 배달을 완료했는지, 아니면 배달 중인지 추적합니다. (readyState)

          //피자가 집에 도착하고 피자가 올바르게 만들어졌는지 확인합니다.피자가 타지 않았는지, 재료를 잘못 넣었는지, 또는 주문대로 내가 원하는 피자가 맞는지 확인합니다. (status)

          //결론적으로, readyState === 4(즉, 피자가 집에 도착했음)이고 status === 200(즉, 피자가 올바르게 만들어졌음)인 경우에만 모든 통신이 계획대로 잘 진행되었다는 것을 의미합니다.
          result = xhr.responseText; //서버가 전송한 HTTP 요청에 대한 응답 문자열
          console.log(result);
          document.querySelector('p').textContent = result;

        }
      }
      xhr.send();// 서버로 요청을 보냅니다. send 메소드가 실행되어야만 우리가 위에서 설정한 내용들이 의미를 가지게 됩니다.
    }

    xhrRequest();

    // console.log(result);

    //데이터들을 화면 갱신없이 서버에서 값을 받아오는 것을 비동기방식, Ajax라고 함
    //브라우저는 페이지를 리프레쉬 하지 않아도 HTTP 요청을 보내 데이터를 전달받아 데이터를 갱신할 수 있었습니다. 이후, 이를 이용한 본격적인 웹앱들이 등장하기 시작합니다. 대표적으로 한번에 수백명에게 메일을 보내는것이 가능한 최초의 서비스인 Gmail, 실시간으로 화면을 업데이트하면서 지도를 볼수 있게 한 Google Maps 등의 앱들이 크게 히트를 치기 시작합니다. 시간이 흘러 ActiveXObject는 XMLHttpRequest라는 이름으로 업데이트 되었고, 그리고 2005년, 제시 제임스 게럿(Jesse James Garrett)이라는 개발자가 이러한 JS 기술을 이용해 비동기적으로 서버와 통신할 수 있는 방법들을 묶어 AJAX라고 명명하여 부르기 시작
    //그럼 AJAX가 나오기 이전에는 서버와 통신이 어떤 식으로 이루어졌었나요? AJAX가 나오기 이전에는 클라이언트가 데이터를 서버에 요청하는 방법은 브라우저 주소창에 특정 URL을 입력하거나, HTML 요소인 <a> 혹은 <form>을 이용하는것 이었습니다.
    //모던 웹에서는 사용 잘 안함(promise등)
    //## 동기 VS 비동기

    // - 일상에서 마주치는 동기와 비동기
    // 1. 마트에서 물건을 구입할 때 계산대에서 손님들이 물건을 계산하러 줄을 섭니다.
    // 2. 첫 손님이 지갑을 찾느라 잠시 계산을 못하는 상황이 발생합니다.
    // 3. 이때 점원이 손님이 지갑을 찾고 돈을 꺼낼 때 까지 가만히 기다리고 있다면 동기적 처리,
    // 4. 기다리면서 동시에 비어있는 옆 계산대로 이동해 첫 손님이 지갑을 찾을 동안 잠시 다음 손님의 계산을 먼저 처리한다면 비동기적 처리라고 볼 수 있습니다.
    //XMLHttpRequest
    //서버와의 비동기 통신을 가능하게 하는 여러 기능들을 가진 자바스크립트 객체
  </script>
</body>

</html>